<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Jogo Mundo Aberto - Controles Corrigidos com Rotação</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
    .info-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: Arial, sans-serif;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
      z-index: 100;
    }
    .audio-controls {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
      z-index: 100;
    }
    .audio-controls button {
      background: #444;
      border: none;
      color: white;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .audio-controls button:hover {
      background: #666;
    }
    .audio-controls input[type="range"] {
      width: 80px;
    }
  </style>
</head>
<body>
  <div class="info-panel">
    <p>Jogador 1 (Vermelho): WASD para mover, Espaço para pular</p>
    <p>Jogador 2 (Azul): Setas para mover, Enter para pular</p>
  </div>

  <div class="audio-controls">
    <button id="playPauseBtn">▶</button>
    <input type="range" id="volumeSlider" min="0" max="1" step="0.1" value="0.5">
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>

  <script>
    // Configuração do áudio
    const audio = new Audio('https://github.com/sfliick77/M-sica-tycon/raw/main/20%20minutes%20and%2050%20seconds%20of%20nostalgic%20roblox%20songs(MP3_160K).mp3');
    audio.loop = true;
    audio.volume = 0.5;
    
    // Controles de áudio
    const playPauseBtn = document.getElementById('playPauseBtn');
    const volumeSlider = document.getElementById('volumeSlider');
    
    let isPlaying = false;
    
    playPauseBtn.addEventListener('click', () => {
      if (isPlaying) {
        audio.pause();
        playPauseBtn.textContent = '▶';
      } else {
        audio.play().catch(e => {
          console.log('Reprodução de áudio precisa de interação do usuário:', e);
          playPauseBtn.textContent = '▶';
          isPlaying = false;
        });
        playPauseBtn.textContent = '⏸';
      }
      isPlaying = !isPlaying;
    });
    
    volumeSlider.addEventListener('input', () => {
      audio.volume = volumeSlider.value;
    });
    
    // Iniciar áudio após primeira interação do usuário
    document.addEventListener('keydown', initAudio, { once: true });
    document.addEventListener('click', initAudio, { once: true });
    
    function initAudio() {
      if (!isPlaying) {
        audio.play().then(() => {
          isPlaying = true;
          playPauseBtn.textContent = '⏸';
        }).catch(e => {
          console.log('Reprodução de áudio não autorizada:', e);
        });
      }
    }

    // Cena e renderizador
    const scene = new THREE.Scene();
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Adicionar céu estrelado
    const skyGeometry = new THREE.SphereGeometry(1500, 32, 32);
    const textureLoader = new THREE.TextureLoader();
    const skyTexture = textureLoader.load('https://github.com/sfliick77/Background-c-u/raw/main/277fba7bc86484d9f6cf37c87ee44de2.jpg');
    skyTexture.wrapS = THREE.RepeatWrapping;
    skyTexture.wrapT = THREE.RepeatWrapping;
    const skyMaterial = new THREE.MeshBasicMaterial({
      map: skyTexture,
      side: THREE.BackSide
    });
    const sky = new THREE.Mesh(skyGeometry, skyMaterial);
    scene.add(sky);

    // Luz
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(50, 100, 50).normalize();
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x555555));

    // Mapa
    const groundGeo = new THREE.PlaneGeometry(2000, 2000);
    const groundMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    // Jogadores
    const player1 = new THREE.Mesh(new THREE.BoxGeometry(20, 20, 20), new THREE.MeshLambertMaterial({ color: 0xff0000 }));
    const player2 = new THREE.Mesh(new THREE.BoxGeometry(20, 20, 20), new THREE.MeshLambertMaterial({ color: 0x0000ff }));
    player1.position.set(-50, 10, 0);
    player2.position.set(50, 10, 0);
    player1.userData.velocity = new THREE.Vector3(0, 0, 0);
    player2.userData.velocity = new THREE.Vector3(0, 0, 0);
    player1.userData.onGround = true;
    player2.userData.onGround = true;
    player1.userData.direction = new THREE.Vector3(0, 0, -1); // Direção inicial
    player2.userData.direction = new THREE.Vector3(0, 0, -1); // Direção inicial
    scene.add(player1);
    scene.add(player2);

    // Casas
    function criarCasa(x, z) {
      const casa = new THREE.Mesh(new THREE.BoxGeometry(80, 60, 80), new THREE.MeshLambertMaterial({ color: 0x8B4513 }));
      casa.position.set(x, 30, z);
      scene.add(casa);
      return casa;
    }
    const casas = [
      criarCasa(200, 200),
      criarCasa(-300, 100),
      criarCasa(150, -250),
      criarCasa(-400, -300)
    ];

    // Obstáculos
    function criarObstaculo(x, z) {
      const obs = new THREE.Mesh(new THREE.BoxGeometry(50, 50, 50), new THREE.MeshLambertMaterial({ color: 0x5555ff }));
      obs.position.set(x, 25, z);
      scene.add(obs);
      return obs;
    }
    const obstaculos = [
      criarObstaculo(0, 300),
      criarObstaculo(-200, -200),
      criarObstaculo(300, -100)
    ];

    // Bola com física melhorada
    const ball = new THREE.Mesh(new THREE.SphereGeometry(30, 32, 32), new THREE.MeshLambertMaterial({ color: 0xffff00 }));
    ball.position.set(0, 30, 0);
    scene.add(ball);
    ball.userData.velocity = new THREE.Vector3(0, 0, 0);
    ball.userData.angularVelocity = new THREE.Vector3(0, 0, 0);

    // Câmeras - Modificadas para estilo Roblox (atrás e acima)
    const camera1 = new THREE.PerspectiveCamera(75, window.innerWidth / (window.innerHeight/2), 0.1, 2000);
    const camera2 = new THREE.PerspectiveCamera(75, window.innerWidth / (window.innerHeight/2), 0.1, 2000);

    // Movimentação
    const keys = {};
    window.addEventListener("keydown", (e) => { 
      keys[e.key] = true; 
      // Impede rolagem da página com teclas de seta e espaço
      if([' ', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        e.preventDefault();
      }
    });
    window.addEventListener("keyup", (e) => { keys[e.key] = false; });

    const speed = 57; // Velocidade aumentada de 5 para 15
    const jumpForce = 50;
    const gravity = 0.8;

    function movePlayers(delta) {
      // Player 1 - WASD + Espaço para pular
      if (keys["w"]) {
        player1.userData.velocity.z = -speed;
        player1.userData.direction.set(0, 0, -1);
      } else if (keys["s"]) {
        player1.userData.velocity.z = speed;
        player1.userData.direction.set(0, 0, 1);
      } else {
        player1.userData.velocity.z = 0;
      }
      
      if (keys["a"]) {
        player1.userData.velocity.x = -speed;
        player1.userData.direction.set(-1, 0, 0);
      } else if (keys["d"]) {
        player1.userData.velocity.x = speed;
        player1.userData.direction.set(1, 0, 0);
      } else {
        player1.userData.velocity.x = 0;
      }
      
      // Combina direções diagonais
      if (keys["w"] && keys["a"]) player1.userData.direction.set(-0.7, 0, -0.7);
      if (keys["w"] && keys["d"]) player1.userData.direction.set(0.7, 0, -0.7);
      if (keys["s"] && keys["a"]) player1.userData.direction.set(-0.7, 0, 0.7);
      if (keys["s"] && keys["d"]) player1.userData.direction.set(0.7, 0, 0.7);
      
      if (keys[" "] && player1.userData.onGround) {
        player1.userData.velocity.y = jumpForce;
        player1.userData.onGround = false;
      }

      // Player 2 - Setas + Enter para pular
      if (keys["ArrowUp"]) {
        player2.userData.velocity.z = -speed;
        player2.userData.direction.set(0, 0, -1);
      } else if (keys["ArrowDown"]) {
        player2.userData.velocity.z = speed;
        player2.userData.direction.set(0, 0, 1);
      } else {
        player2.userData.velocity.z = 0;
      }
      
      if (keys["ArrowLeft"]) {
        player2.userData.velocity.x = -speed;
        player2.userData.direction.set(-1, 0, 0);
      } else if (keys["ArrowRight"]) {
        player2.userData.velocity.x = speed;
        player2.userData.direction.set(1, 0, 0);
      } else {
        player2.userData.velocity.x = 0;
      }
      
      // Combina direções diagonais
      if (keys["ArrowUp"] && keys["ArrowLeft"]) player2.userData.direction.set(-0.7, 0, -0.7);
      if (keys["ArrowUp"] && keys["ArrowRight"]) player2.userData.direction.set(0.7, 0, -0.7);
      if (keys["ArrowDown"] && keys["ArrowLeft"]) player2.userData.direction.set(-0.7, 0, 0.7);
      if (keys["ArrowDown"] && keys["ArrowRight"]) player2.userData.direction.set(0.7, 0, 0.7);
      
      if (keys["Enter"] && player2.userData.onGround) {
        player2.userData.velocity.y = jumpForce;
        player2.userData.onGround = false;
      }

      // Aplica gravidade
      player1.userData.velocity.y -= gravity;
      player2.userData.velocity.y -= gravity;

      // Atualiza posição dos jogadores
      player1.position.add(player1.userData.velocity.clone().multiplyScalar(delta));
      player2.position.add(player2.userData.velocity.clone().multiplyScalar(delta));

      // Rotaciona os jogadores na direção do movimento
      if (player1.userData.velocity.x !== 0 || player1.userData.velocity.z !== 0) {
        player1.rotation.y = Math.atan2(player1.userData.direction.x, player1.userData.direction.z);
      }
      
      if (player2.userData.velocity.x !== 0 || player2.userData.velocity.z !== 0) {
        player2.rotation.y = Math.atan2(player2.userData.direction.x, player2.userData.direction.z);
      }

      // Verifica colisão com o chão
      if (player1.position.y <= 10) {
        player1.position.y = 10;
        player1.userData.velocity.y = 0;
        player1.userData.onGround = true;
      }
      
      if (player2.position.y <= 10) {
        player2.position.y = 10;
        player2.userData.velocity.y = 0;
        player2.userData.onGround = true;
      }
    }

    // Colisão melhorada entre jogadores e bola
    function checkBallCollision(player, delta) {
      const dist = player.position.distanceTo(ball.position);
      const combinedRadius = 15 + 30; // Raio do jogador + raio da bola
      
      if (dist < combinedRadius) {
        // Calcula direção do impulso
        const pushDir = new THREE.Vector3().subVectors(ball.position, player.position).normalize();
        
        // Calcula força baseada na velocidade do jogador
        const playerSpeed = player.userData.velocity.length();
        const force = 5 + playerSpeed * 0.5;
        
        // Aplica força na bola
        ball.userData.velocity.add(pushDir.multiplyScalar(force));
        
        // Adiciona efeito visual de rotação na bola
        const rotationForce = new THREE.Vector3(
          -pushDir.z * force * 0.01,
          0,
          pushDir.x * force * 0.01
        );
        ball.userData.angularVelocity.add(rotationForce);
      }
    }

    // Atualizar bola com física melhorada
    function updateBall(delta) {
      // Aplica atrito apenas no eixo XZ
      ball.userData.velocity.x *= 0.98;
      ball.userData.velocity.z *= 0.98;
      
      // Aplica atrito de rotação
      ball.userData.angularVelocity.multiplyScalar(0.95);
      
      // Aplica gravidade à bola
      ball.userData.velocity.y -= gravity * 0.5;
      
      // Atualiza posição
      ball.position.add(ball.userData.velocity.clone().multiplyScalar(delta));
      
      // Atualiza rotação
      ball.rotation.x += ball.userData.angularVelocity.x;
      ball.rotation.z += ball.userData.angularVelocity.z;
      
      // Colisão com o chão
      if (ball.position.y <= 30) {
        ball.position.y = 30;
        
        // Efeito de quique com perda de energia
        ball.userData.velocity.y *= -0.7;
        
        // Atrito adicional ao tocar o chão
        ball.userData.velocity.x *= 0.9;
        ball.userData.velocity.z *= 0.9;
      }
      
      // Limites do mapa com efeito de quique
      const boundary = 900;
      if (ball.position.x > boundary || ball.position.x < -boundary) {
        ball.userData.velocity.x *= -0.8;
        ball.position.x = THREE.MathUtils.clamp(ball.position.x, -boundary, boundary);
      }
      if (ball.position.z > boundary || ball.position.z < -boundary) {
        ball.userData.velocity.z *= -0.8;
        ball.position.z = THREE.MathUtils.clamp(ball.position.z, -boundary, boundary);
      }
    }

    function updateCameras() {
      // Câmera do Player 1 - estilo Roblox (atrás e acima)
      const cameraDistance = 50;
      const cameraHeight = 30;
      
      // Calcula a direção para a qual o jogador está olhando
      const player1Direction = new THREE.Vector3(
        Math.sin(player1.rotation.y),
        0,
        Math.cos(player1.rotation.y)
      );
      
      // Posiciona a câmera atrás e acima do jogador
      camera1.position.set(
        player1.position.x - player1Direction.x * cameraDistance,
        player1.position.y + cameraHeight,
        player1.position.z - player1Direction.z * cameraDistance
      );
      camera1.lookAt(player1.position.x, player1.position.y + 10, player1.position.z);

      // Câmera do Player 2 - estilo Roblox (atrás e acima)
      const player2Direction = new THREE.Vector3(
        Math.sin(player2.rotation.y),
        0,
        Math.cos(player2.rotation.y)
      );
      
      camera2.position.set(
        player2.position.x - player2Direction.x * cameraDistance,
        player2.position.y + cameraHeight,
        player2.position.z - player2Direction.z * cameraDistance
      );
      camera2.lookAt(player2.position.x, player2.position.y + 10, player2.position.z);
    }

    // Loop com controle de tempo delta
    let clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      
      const delta = Math.min(clock.getDelta(), 0.1); // Controla o delta para evitar problemas
      
      movePlayers(delta);
      checkBallCollision(player1, delta);
      checkBallCollision(player2, delta);
      updateBall(delta);
      updateCameras();

      // Render Player 1
      renderer.setViewport(0, 0, window.innerWidth / 2, window.innerHeight);
      renderer.setScissor(0, 0, window.innerWidth / 2, window.innerHeight);
      renderer.setScissorTest(true);
      renderer.render(scene, camera1);

      // Render Player 2
      renderer.setViewport(window.innerWidth / 2, 0, window.innerWidth / 2, window.innerHeight);
      renderer.setScissor(window.innerWidth / 2, 0, window.innerWidth / 2, window.innerHeight);
      renderer.setScissorTest(true);
      renderer.render(scene, camera2);
    }
    animate();

    // Responsividade
    window.addEventListener("resize", () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera1.aspect = (window.innerWidth/2) / window.innerHeight;
      camera2.aspect = (window.innerWidth/2) / window.innerHeight;
      camera1.updateProjectionMatrix();
      camera2.updateProjectionMatrix();
    });
  </script>
</body>
</html> 
